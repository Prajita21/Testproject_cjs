<!DOCTYPE html>
<html lang="en">
<link>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Image</title>
    <link rel="stylesheet" type="text/css" href="style.css">
</head>
<body>
        <!-- div that will hold our WebGL canvas -->
        <div id="canvas"></div>
        <!-- div used to create our plane -->
        <div class="plane">
        <!-- image that will be used as texture by our plane -->
        <img src="image1.JPG" crossorigin="" />
        </div>
        <script type="module">
            import {Curtains, Plane} from "https://cdn.jsdelivr.net/npm/curtainsjs@7.2.0/src/index.mjs";
// wait for everything to be ready
window.addEventListener("load", () => {
// set up our WebGL context and append the canvas to our wrapper
const curtains = new Curtains({
container: "canvas"
});
// get our plane element
const planeElement = document.getElementsByClassName("plane")[0];
// set our initial parameters (basic uniforms)
const params = {
vertexShaderID: "plane-vs", // our vertex shader ID
fragmentShaderID: "plane-fs", // our fragment shader ID
uniforms: {
time: {
name: "uTime", // uniform name that will be passed to our shaders
type: "1f", // this means our uniform is a float
value: 0,
},
},
};
// create our plane using our curtains object, the HTML element and the parameters
const plane = new Plane(curtains, planeElement, params);
plane.onRender(() => {
// use the onRender method of our plane fired at each requestAnimationFrame call
plane.uniforms.time.value++; // update our time uniform value
});
});

 </script>
    <!-- vertex shader -->
<script id="plane-vs" type="x-shader/x-vertex">
precision mediump float;
// those are the mandatory attributes that the lib sets
attribute vec3 aVertexPosition;
attribute vec2 aTextureCoord;
// those are mandatory uniforms that the lib sets and that contain our model view and projection matrix
uniform mat4 uMVMatrix;
uniform mat4 uPMatrix;
// our texture matrix that will handle image cover
uniform mat4 uTextureMatrix0;
// pass your vertex and texture coords to the fragment shader
varying vec3 vVertexPosition;
varying vec2 vTextureCoord;
varying vec2 vOriginalTextureCoord;
void main() {
vec3 vertexPosition = aVertexPosition;
vertexPosition.z = sin(vertexPosition.x * 3.141592 + uTime * 0.0375) * 0.05;
// using About the plane's attributes : aVertexPosition and aTextureCoord
gl_Position = uPMatrix * uMVMatrix * vec4(<a href=""></a>vertexPosition, 1.0);
// set the varyings
// here we use our texture matrix to calculate the accurate texture coords
vOriginalTextureCoord = aTextureCoord;
vTextureCoord = (uTextureMatrix0 * vec4(aTextureCoord, 0.0, 1.0)).xy;
vVertexPosition = vertexPosition;
}
</script>
<!-- fragment shader -->
<script id="plane-fs" type="x-shader/x-fragment">
precision mediump float;
// get our varyings
varying vec3 vVertexPosition;
varying vec2 vTextureCoord;
// the uniform we declared inside our javascript
uniform float uTime;
// our texture sampler (default name, to use a different name please refer to the documentation)
uniform sampler2D uSampler0;
void main() {
// get our texture coords from our varying
vec2 textureCoord = vTextureCoord;
// displace our pixels along the X axis based on our time uniform
// textures coords are ranging from 0.0 to 1.0 on both axis
textureCoord.x += sin(textureCoord.y * 15.0) * cos(textureCoord.x * 200.0) * (cos(uTime / 50.0)) / 25.0;
// map our texture with the texture matrix coords
//gl_FragColor = texture2D(uSampler0, textureCoord);
gl_FragColor = vec4(vec3(vTextureCoord.y), 1.0);
//vec2 st = gl_FragCoord.xy/uResolution.xy;
}
 </script>
</body>
</html>